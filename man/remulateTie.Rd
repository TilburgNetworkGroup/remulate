% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/remulateTie.R
\name{remulateTie}
\alias{remulateTie}
\title{Simulate Temporal Events Network - Tie based model}
\usage{
remulateTie(
  effects,
  actors,
  time,
  events = NULL,
  initial = 0,
  riskset = NULL,
  memory = c("full", "window", "brandes", "vu"),
  memory_param = NULL,
  seed = NULL
)
}
\arguments{
\item{effects}{an object of type \code{formula} for specification of statistics used to simulate the network.}

\item{actors}{Numeric or character vector of actor names.}

\item{time}{Numeric, time upto which to simulate network.}

\item{events}{[Optional] Integer, maximum number of events to simulate.}

\item{initial}{[Optional] (default = 0) Numeric or data.frame object indicating how to initialize the network. ' integer' value denotes the number of random events to sample before beginning with the data generation. data.frame with columns (time,sender,receiver), it is an edgelist of initial events following which the subsequent events are predicted.}

\item{riskset}{[Optional] \code{data.frame} object wtih columns (sender, receiver) for custom risk set}

\item{memory}{[Optional] (default = full) String indicating which.
 memory type to use. "full" uses the entire event history to compute statistics, "window" memory indicates a window in the past upto.
which occured events will be remembered for computing statistics, "brandes" memory type uses past events
weighted by their time, "vu" memory type uses past events weighted by 1/time since event occured.}

\item{memory_param}{[Optional] value > 0. For memory type "window" this parameter indicates the length (in time units) of the window. For memory type "brandes" the memory_param is the half-life i.e the time until an event has a weight of one half. For memory type "vu" the memory_param is power of (1/time since event occured).}

\item{seed}{[Optional] Seed for random number stream.}
}
\value{
\describe{
\item{edgelist}{data.frame object with columns (time,sender,receiver)}
\item{statistics}{array of statistics with dimensions M x D x P (M: Number of events, D: Number of dyads in the risk set, P: Number of statistics)}
\item{evls}{matrix containing the event list  with columns (dyad,time) where dyad represents the index of the dyad or the (sender,receiver) pair in the riskset}
\item{actors_map}{data.frame object containing the mapping of actor names provided by user in \code{actors} argument to the integer ids used in the internal computations}
\item{riskset}{data.frame object  wtih columns (sender, receiver) containing the risket set used for the dyad indices in the statistics and evls}
\item{density}{numeric value indicating density in the generated network i.e number of observed ties / N*(N-1) (N:number of actors)}
}
}
\description{
A function to simulate relational event data by sampling from a
tie based relational event model.
}
\details{
A list of available statistics. See \link{remulateTieEffects} for details:
\itemize{
 \item \code{baseline(param)}
 \item \code{send(param, variable, attributes, scaling=c("raw","std"))}
 \item \code{receive()}
 \item \code{same()}
 \item \code{difference()}
 \item \code{average()}
 \item \code{minimum()}
 \item \code{maximum()}
 \item \code{inertia()}
 \item \code{reciprocity()}
 \item \code{tie()}
 \item \code{indegreeSender()}
 \item \code{indegreeReceiver()}
 \item \code{outdegreeSender()}
 \item \code{outdegreeReceiver()}
 \item \code{totaldegreeSender()}
 \item \code{totaldegreeReceiver()}
 \item \code{otp()}
 \item \code{itp()}
 \item \code{osp()}
 \item \code{isp()}
 \item \code{psABBA()}
 \item \code{psABBY()}
 \item \code{psABXA()}
 \item \code{psABXB()}
 \item \code{psABXY()}
 \item \code{psABAY()}
 \item \code{interact()}
}
}
\examples{
 # To generate events upto time '50' in a network of 25 actors with 
 # 200 random initial events
 
 #exogenous attributes data.frame
 cov <- data.frame(id=1:25, time=rep(0,25), sex=sample(c(0,1),25,replace=T,prob=c(0.4,0.6)), age=sample(20:30,25,replace=T) )
 
 #effects specification
 effects <- ~ remulate::baseline(-5) + remulate::inertia(0.01) + remulate::reciprocity(-0.04)+
 remulate::itp(0.01,scaling="std") + remulate::same(0.02,variable="sex",attributes = cov) + remulate::interact(0.01,indices=c(2,5))
 
 #calling remulateTie
 remulate::remulateTie(effects, actors = 1:25, time =50, events = 500, initial = 200)
 
 # To predict events, given an edgelist of initial events
 initialREH <- data.frame(time = seq(0.5,100,0.5), sender = sample(1:25,200,T), receiver = sample(1:25,200,T))
 remulate::remulateTie(effects, actors=1:25, time=150, initial=initialREH, events = 500, seed=123)
 
}
