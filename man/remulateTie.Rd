% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/remulateTie.R
\name{remulateTie}
\alias{remulateTie}
\title{Simulate Temporal Events Network - Tie based model}
\usage{
remulateTie(
  effects,
  actors,
  time,
  events = NULL,
  startTime = 0,
  initial = 0,
  riskset = NULL,
  memory = c("full", "window", "decay"),
  memoryParam = NULL
)
}
\arguments{
\item{effects}{an object of type \code{formula} for specification of statistics used to simulate the network.}

\item{actors}{Numeric or character vector of actor names.}

\item{time}{Numeric, time upto which to simulate network.}

\item{events}{[Optional] Integer, maximum number of events to simulate.}

\item{startTime}{[Optional] (default = 0) Numeric specifying the time at which to initialize the simulation}

\item{initial}{[Optional] (default = 0) Numeric or data.frame object indicating how to initialize the network. ' integer' value denotes the number of random events to sample before beginning with the data generation. data.frame with columns (time,sender,receiver), it is an edgelist of initial events following which the subsequent events are predicted.}

\item{riskset}{[Optional] \code{matrix} object wtih columns (sender, receiver) for custom risk set}

\item{memory}{[Optional] (default = full) String indicating which.
 memory type to use. "full" uses the entire event history to compute statistics, "window" memory indicates a time window in the past upto.
which occured events will be remembered for computing statistics, "window_m" memory indicates a window (number of events) in the past upto.
which occured events will be remembered for computing statistics, "decay" memory type allows for an exponential decay of past events
weighted by elapsed time.}

\item{memoryParam}{[Optional] value > 0. For memory type "window" this parameter indicates the length (in time units) of the window.
For memory type "window_m" this parameter indicates the length (in number of events) of the window. 
For memory type "decay" the memoryParam is the half-life i.e the time until an event has a weight of one half.}
}
\value{
\describe{
\item{edgelist}{data.frame object with columns (time,sender,receiver)}
\item{statistics}{array of statistics with dimensions M x D x P (M: Number of events, D: Number of dyads in the risk set, P: Number of statistics)}
\item{evls}{matrix containing the event list  with columns (dyad,time) where dyad represents the index of the dyad or the (sender,receiver) pair in the riskset}
\item{actors}{data.frame object containing the mapping of actor names provided by user in \code{actors} argument to the integer ids used in the internal computations}
\item{riskset}{data.frame object  wtih columns (sender, receiver) containing the risket set used for the dyad indices in the statistics and evls}
\item{density}{numeric value indicating density in the generated network i.e number of observed ties / N*(N-1) (N:number of actors)}
}
}
\description{
A function to simulate relational event data by sampling from a
tie based relational event model.
}
\details{
A list of available statistics. See \link{remulateTieEffects} for details:
\itemize{
 \item \code{baseline(param)}
 \item \code{send()}
 \item \code{receive()}
 \item \code{dyad()}
 \item \code{same()}
 \item \code{difference()}
 \item \code{average()}
 \item \code{minimum()}
 \item \code{maximum()}
 \item \code{inertia()}
 \item \code{reciprocity()}
 \item \code{tie()}
 \item \code{indegreeSender()}
 \item \code{indegreeReceiver()}
 \item \code{outdegreeSender()}
 \item \code{outdegreeReceiver()}
 \item \code{totaldegreeSender()}
 \item \code{totaldegreeReceiver()}
 \item \code{otp()}
 \item \code{itp()}
 \item \code{osp()}
 \item \code{isp()}
 \item \code{psABBA()}
 \item \code{psABBY()}
 \item \code{psABXA()}
 \item \code{psABXB()}
 \item \code{psABXY()}
 \item \code{psABAY()}
 \item \code{recencyContinue()}
 \item \code{recencySendSender()}
 \item \code{recencySendReceiver()}
 \item \code{recencyReceiveSender()}
 \item \code{recencyReceiveReceiver()} 
 \item \code{rrankSend()} 
 \item \code{rrankReceive()} 
 \item \code{interact()}
}
}
\examples{
 # To generate events up to time '50' in a network of 25 actors with 
 # 200 random initial events
 
 # Exogenous attributes data.frame
 cov <- data.frame(
   id = 1:25, 
   time = rep(0, 25), 
   sex = sample(c(0, 1), 25, replace = TRUE, prob = c(0.4, 0.6)), 
   age = sample(20:30, 25, replace = TRUE) 
 )
 
 # Effects specification
 effects <- ~ remulate::baseline(-5) + 
             remulate::inertia(0.01) + 
             remulate::reciprocity(-0.04) + 
             remulate::itp(0.01, scaling = "std") + 
             remulate::same(0.02, variable = "sex", attributes = cov) + 
             remulate::interact(0.01, indices = c(2, 5))
 
 # Calling remulateTie
 remulate::remulateTie(
   effects, 
   actors = 1:25, 
   time = 50, 
   events = 500, 
   initial = 200
 )
 
 # To predict events, given an edgelist of initial events
 initialREH <- data.frame(
   time = seq(0.5, 100, 0.5), 
   sender = sample(1:25, 200, TRUE), 
   receiver = sample(1:25, 200, TRUE)
 )
 
 remulate::remulateTie(
   effects, 
   actors = 1:25, 
   time = 150, 
   events = 500, 
   initial = initialREH
 )
 
 # Custom risk set
 rs <- as.matrix(expand.grid(1:25, 1:25))
 rs <- rs[rs[, 1] != rs[, 2], ]
 
 custom_rs <- rs[sample(1:90, 50), ]
 
 remulate::remulateTie(
   effects, 
   actors = 1:25, 
   time = 150, 
   events = 500, 
   riskset = custom_rs
 )
}
